# 原型

## 原型的定义

1. 显示原型对象(函数)

   - 原型就是一个对象，对象就是一个普通的对象
   - 每个函数都有一个属性 prototype，该属性指向的是一个空的 Object 实例对象,js 引擎会自动给该对象添加一个 constructor 属性

2. 隐式原型对象(实例对象)
   - 每一个实例对象身上都有一个\_\_proto\_\_的属性,该属性指向的也是一个对象

## 为什么要设计原型

1. 节省内存空间
2. 节省代码量
3. 实现继承

## 原型链

1. 查找对象的属性的时候先在自身找
2. 如果自身没有，沿着\_\_proto\_\_这条链查找
3. 直到找到 Object 的显示原型对象
4. 如果还没有返回 undefined
5. \_\_proto\_\_这条链就是原型链

## 理解 函数对象 概念

1. 函数是特殊的对象
2. 和普通对象的区别是函数可以调用，具备行为

## instanceof 运作原理

1. A instanceof B 判断 A 是否是 B 的实例
2. 判断的依据： B.prototype 是否出现在 A 的原型链上，只要出现判断结果就是 true

## 变量提升(预解析)

1. js 引擎在代码正式执行之前会做一些预解析的工作

   - 找关键字 var function
   - 找到 var 将 var 后边的变量提前声明，但是不赋值 var a;
   - 找到 function 以后提前 定义 该函数

2. 效果

   - 在 var 语句之前可以访问 var 后边的变量不会报错，但是值是 undefined
   - 在函数体之前可以调用该函数

3. 特例：

   - 函数和变量同名的时候预解析的结果永远是函数
   - 原因：
     - function 的优先级高于 var
     - 顺序预解析： 个人理解

# 执行上下文

## 执行上下文环境

1. js 引擎在代码正式执行之前先创建环境(执行上下文环境)，并进入
2. 进入环境之后会做以下事情

   - 创建一个空对象(执行上下文对象)
   - 该对象用于收集：变量，函数，函数的参数 ---> 变量提升
   - 确认 this 的指向： 全局： this ---> window(全局的执行上下文对象)， 局部：this ---> 调用函数的对象
   - 创建作用域链

3. 特殊

   - 函数的局部执行上下文对象没有可见指针
   - 函数预解析的时候遇到 function 会先去找是否调用再决定是否定义内部函数

## 执行上下文对象

- 创建一个空对象(执行上下文对象)

## 执行上下文栈

1. 先进后出
2. 后进先出

# 作用域

## 作用域定义

- 代码作用的范围

## 作用域的作用

- 隔离变量

## 作用域什么时候产生

- 代码定义的时候产生

## 作用域链

- 当查找变量的时候现在自身所处的作用域的执行上下文对象去找
- 如果没有去外层作用域的执行上下文对象去找
- 知道找到全局的执行上下文对象，如果还没有报错： xxx is not defined

# JS 执行机制

1. 创建执行上下文环境
2. 创建空对象，收集变量、函数以及函数的参数
3. 创建作用域链
4. 确认 this 的指向

# 函数的 this

1. this 是一个关键字，在变量声明的时候不能使用 this
2. this 的本质也是一个变量，只不过在函数未调用的时候没有具体的指向
3. 函数的 this 不是在函数定义的时候决定的，而是在函数调用的时候决定的。谁调用这个函数 this 就指向谁

# 闭包

## 闭包的定义

1. 闭包是一个闭合的容器
2. 闭包就是一个对象: {key: value}

## 闭包产生的条件

1. 函数嵌套
2. 内部函数引用外部函数的局部变量

## 闭包的特点

1. 闭包就是一个对象: {key: value}
2. 保存在内部函数中

## 闭包的作用 || 优点

1. 延长外部函数局部变量（内部函数牵引的变量）的生命周期
2. 可以在外部访问函数内部的局部变量

## 闭包的缺点

1. 闭包如果不及时清除的话会长期占用内存
2. 多次使用闭包的话容易造成内存溢出

## 使用闭包的时候注意什么

1. 能不用就不用
2. 用完及时清除闭包

```javascript
function fun() {
  var num = 123;
  var a = "abc";
  function fun2() {
    console.log(num);
  }
  return fun2;
}

var fun2 = fun();
fun2();
fun2 = null;
```

## 闭包的使用场景

1. 循环遍历加监听
2. 在函数的外部需要操作函数内部的局部变量的时候
3. 封装 js 功能库的时候
4. React 和 Vue 中在组件的生命周期函数里一定有闭包，局部变量指的是 this 或者其他

## 同步与异步

1. 同步
   - 同步会阻塞后续代码的执行
   - 同步没有回调
2. 异步
   - 异步是非阻塞的
   - 异步一定有回调函数

## 对象的创建方式

1. object 构造函数方式，缺点:语句太多，流程太啰嗦
2. 对象的字面量创建方式，优点:书写简单，方便，直观。缺点:有太多重复的代码
3. 工厂模式:优点:避免重复的代码，可以批量生产对象，缺点:不能明确区分属于哪一类
4. 自定义构造函数模式:优点:可以生产多个实例对象。缺点:方法如果直接定义给实例本身的话太占

## 继承

1. 原型继承:

- 子类的原型对象===父类的实例，例如:child.prototype = new Parent();
- 注意点:以上的步骤会导致子类原型的构造器属性丢失，所以需要手动添加构造器属性- child.prototype.constructor = child;

2. 借用构造函数继承(不是真正意义上的继承)

- 在子类的构造函数中调用父类的构造函数-注意点:父类构造函数的 this 指向问题
- 解决方案:通过 call/apply 强制修改 this 的指向―---〉当前子类的实例对象

## 事件循环机制

1. js 是单线程的，所有的代码都会在 js 的主线程执行
2. 同步任务加载即执行
3. 异步任务(定时器，事件的回调，网络请求)不会立马执行结束，会交由对应的管理模块去管理
4. 对应的管理模块在异步任务满足条件之后将对应的回调函数放在 callback queue 中
5. 主线程上同步任务执行完毕会询问 callback queue 中是否有可执行的回调，如果有，就将回调函数钩出去放在主线程执行
6. 主线程上的代码执行结束后会反复的去询问 callback queue，又叫 event loop ----> 事件轮询机制 查看事件是否有可执行的回调函数，有则将回调钩到主线程上执行。如果没有则过一会再询问

# 重要概念

原型，作用域，闭包，继承，this，执行上下文

# 作用域

作用域在函数定义的时候就已经产生，直至浏览器页面的关闭才会销毁

# 垃圾回收机制： 是一个循环机制

1. 计数清除：IE 低版本以及旧的 chrome

   看内存的地址身上有几个指针指向，当一块内存地址身上指针个数为 0，说明这块内存马上就要被回收

2. 标记清除
   进入到代码执行的环境以后检测到需要使用的变量就在其身上加一个进场标记，在代码执行完后就会在之前加标记的变量的身上再添加一个出场标记，当进场标记和出场标记同时存在一个变量上时就销毁该变量的内存

# JSON 对象

- JSON 字符串特征：最外城是单引号，里面的每一项用双引号；例：var obj = '{"name":"kobe"}';
- JSON.stringify(obj/arr):js 对象/数组转换为 json 对象/数组
- JSON.parse（json）：json 对象/数组转换为 js 对象/数组

# es5 给 Object 扩展的静态方法

1. Object.create(prototype,[descriptors])，返回一个新的对象.
   第一个参数时要把该对象/构造函数作为自身的构造函数，第二个参数是需要添加的属性.

   第二个参数添加的属性有四个值：

   - value(属性值)
   - writable（是否可修改，默认为 false）
   - configurable（是否可以删除，默认 false）
   - enumerable（能否用 for in 遍历，默认 false）

```javascript
var obj = {
   name:'jenny',
   age:18,
   setName:function(){
      this.name = 'angle';
   }
}

var obj2 = {};
obj2 = Object.create(obj,{
   sex:{
      value:'女',
      [writable]
   }
   })
```

2. Object.defineProperties(object,descriptors).为指定对象定义扩展多个属性

```javascript
var obj = {
   name:'jenny',
   age:18,
   setName:function(){
      this.name = 'angle';
   }
}

var obj2 = {};
obj2 = Object.defineProperties(obj,{
   sex:{
     get: function(){
        return '男';
     },
      set: function(value){
         console.log("value")
      }
     }
   }
   })

obj2.sex = '女';//当有这个设置的时候set就会自动接收值并设置值
```

## bind

改变 this 指向

```javascript
var obj = {
  name: "tom",
};
function fun(msg) {
  console.log(this);
  console.log(msg);
}
fun2 = fun.bind(obj, "bind传入的参数");
fun2();
//{ name: 'tom' }
//bind传入的参数
fun.bind(obj, "bind传入的参数")();
//{ name: 'tom' }
//bind传入的参数
```

## call、apply、bind 的区别

- bind 不会立即执行函数，当我们要为回调函数绑定 this 只能用 bind。如，定时器

```javascript
setTime;
```

## let

1. 作用:

- 与 var 类似, 用于声明一个变量

2. 特点:

- 在块作用域内有效
- 不能重复声明
- 不会预处理, 不存在提升

3. 应用:

- 循环遍历加监听
- 使用 let 取代 var 是趋势
